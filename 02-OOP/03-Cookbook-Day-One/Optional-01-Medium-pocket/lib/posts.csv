mskog/visual-studio-code-plugins-for-ruby-2096,Visual Studio Code plugins for Ruby and Rails,"A quick list of all the plugins I use for Ruby on Rails development.

You will need this for syntax support and such so this is a must have.

This one is a must have. It will enable ""Go to definition"" in Ruby for all classes, modules and methods. It also has context-aware code completion and documentation. Extremely handy. If you only choose one of the plugins on this list(except for the Ruby one) then make it this one. It is quite something!

If you use Rubocop then this extension will let your format your code using Rubocop. This is highly recommended as it will enforce a consistent style in your code. Especially if you are working in a team.

Pro tip: If you use Spring then you can use spring-commands-rubocop to make a binstub for Rubocop and then it will run much faster. You will need to set the ""ruby.rubocop.executePath"" setting in VSCode to ""bin/"" for this to work properly.

If you are using the default Rails way of organizing directories and such then this plugin can make navigating your application a breeze. You can use it to quickly navigate between controller actions, model, views and even specs.

This will enable the use of ""Go to definition"" in VSCode for view partials. Very handy for quickly navigating through a complex view structure.

This is a simple extension that will open the latest migration in your application. I use it all the time so it is absolutely worth having.

If you use RSpec then this is a handy extension. It will make it very easy to add focus: true to your specs to run only that spec.

Quickly toggle ERB tags in your views. Will save you quite a bit of typing.

Syntax support for Haml.

This uses the haml-lint gem to help you make your Haml code clean and consistent.

Add end automatically to methods and statements.

If you use the Dash documentation browser for Mac then you can use this extension to quickly jump to the documentation for any class or method.

Quickly jump to the open file on Github.

This will copy the relative path of any file as defined by the project root. Great for doing things like running a specific spec and such.

Will add intellisense for any CSS class in your project, even those defined in external style sheets like Bootstrap.

No-nonsense formatter for HTML, CSS, Javascript and more. It is opinionated and does not allow for much configuration. It is perfect if you want something simple and don't want to fiddle with configuration files.

Another formatter. This one is a ""meta formatter"" that uses other formatters. You can thus use Prettier for CSS and something else for HTML, all managed by Unibeautify. This is also the only formatter that I know of that does a decent job of handling ERB templates. Use the Pretty diff formatter for ERB templates and you will have a pretty good time.

Vim
This will essentially turn VSCode into VIM for editing. I gave this a shot and didn't look back. It might take you a couple of weeks to get proficient with it but after that you'll be golden. This is in my opinion an excellent plugin and it will make you a lot more efficient. Check out this article for a very good introduction to this plugin.

There you go! Those are all my plugins for Ruby on Rails development. Did I miss one? Let me know on Twitter!",Magnus Skog,true
molly_struve/level-up-your-ruby-skillz-working-with-arrays-hnn,Level Up Your Ruby Skillz: Working With Arrays,"When I first started out, there was a senior engineer that I worked with who was a wizard when it came to working with arrays. He taught me all the best tricks to writing succinct and clean code when it came to dealing with arrays. Here are the methods that I find the most useful and I think are good to have in your Ruby toolbox right from the start.

If you want to jump straight to the code without the explanations checkout the cheatsheet at the bottom!



Before we dive into some of the fancier methods above, we first need to start with the most basic, each. each will call a block once for every given element in an array. When it is done, it will return the original array. That last part is key and is easy to forget. Even those of us who have been working with Ruby for a while sometimes forget it. Here is an example.

That code will produce the following result when run in a console. NOTE: In the example below and those that follow, irb simply means I am in a Ruby console.

For each number in our array we printed ""hi"" plus that number. Then, after we have finished traversing the entire array, our original array is returned.

Keep in mind, I am using the do/end block notation above, but you can also use the bracket syntax for your block which is shown below.

As you can see, regardless of syntax, the result is the same. I am going to continue to use the do/end syntax throughout this guide because I think it makes the code and logic easier to understand. With that said, all of these methods will work with the bracket syntax as well.



In the early days, when I was new to Ruby, every time I wanted to build an array I did something like this:

I quickly learned there was a better way, and that is by using map. map returns a new array with the results of executing the block once for every element in your original array. Here is an example:

We add 2 to every number in our original array and then group those results up into a new array, which is returned. Now our code is a bit cleaner and more compact.



map is great for collecting a set of results, but what happens when you want to map over nested arrays? That is when flat_map comes in handy. If you find yourself with a set of nested arrays then you might want to checkout flat_map. For example, say you have code like this with a couple of nested arrays.

We get a single level array, which is what we wanted, but how could we tighten this up? Let's try using map.

Hmmm, that is not quite what we want. We want a flat, single level array and map is creating a nested one. In order to flatten that nested array we can use flat_map.

flat_map works similar to map in that it collects the results from your block into an array, but as a bonus, it will flatten it. Under the hood, flat_map is concatenating all of the inner arrays into a single one. Using flat_map returns that single level array we wanted.



Similar to the map example, when I was starting out, if I wanted to conditionally select elements from an array, for example, choose all the even numbers, I would do something like this:

It works, but there is an even more succinct way, and that is by using select. select returns an array containing all elements for which the given block returns a true value. This means we can rewrite our above block of code like this!



Now we are going to kick it up a notch. What if instead of wanting all the even numbers back from an array, you only want the first even number that you find? For that you can use detect. detect will return the first entry for which your block evaluates to true. So if we run a similar block of code as above, but replace select with detect, you can see we get back only the first even number.

One important thing to note here is that we are now returning a number(our entry) and NOT an array.

But what happens if our block never evaluates to true? What if there are no even numbers in our array? In that case, detect will return nil.

To summarize, detect will return the first entry your block evaluates to true for OR it will return nil if no entry evaluates to true for your block.



Now let's look at the inverse of select, which is reject. reject will return all entries for which your block evaluates FALSE. So instead of doing this:

We can simplify the above code and do something like this instead:

This time we will return each number which is not even, so those where number.even? returns false.



We have just seen two ways we can filter through arrays in Ruby using select and reject. But what if you want to straight up separate your single array into two arrays, one for even numbers and one for odd numbers? One way to accomplish this is by doing:

But, there is an even better way, you can use partition! Hold on to your seats for this one. partition will return TWO arrays, the first containing the elements of the original array for which the block evaluated true and the second containing the rest. This means we can take what we wrote above and simplify it to:

As you can see, partition will return two arrays, one with even numbers, and one for odd numbers. If we want to assign our even and odd variables all we have to do is

However, as you can probably guess, there is an even better way! We can eliminate that single result variable altogether and write something like this

This syntax is going to automatically assign the first array to even and the second array to odd. You can use this array assignment syntax anytime you are dealing with nested arrays. Here is an example of how you can breakup 3 arrays.



count for the most part is pretty self explanatory, by default, it will count the number of elements in your array.

But, did you know it can do so much more? For starters, can pass count an argument. If you pass count an argument, it will count the number of times that argument occurs in your array.

You can also pass count a block!😲When passed a block, count will return the count for the number of entries that block evaluates to true for.

Every number that is odd in our array was counted and the result returned was 4.



Last but not least, I want to talk about traversing an array with an index. Often when we want to keep track of where we are in an array of elements we will do something like this.

However, there is a better way! You can use with_index with each, or any of the methods I listed above, to help you keep track of where you are in an array. Here are some examples of how you can use it. (REMEMBER: Array indexes start at 0 😃)

In this example we are simply iterating over our array and printing out the index for each element.

In this example, we are combining the index with the letter in our array to form a new array using the map method.

This example is a little trickier. Here we are using our index to help us select the element in our array that is at index equal to 2. In this case, that element is ""c"".



The last tidbit of knowledge I want to leave you with is that any of the methods above that return an array(all except count and detect), you can chain together. For these examples I am going to use bracket notation because I think it's easier to read chaining methods from left to right rather than up and down.

For example, you can do this:

Let's break down what is happening here given what we learned above.
1) map is going to add 2 to each of our array elements and return [3, 4, 5, 6]
2) select will select only the even numbers from that array and return [4, 6]
3) reject will remove any number equal to 6 which leaves us with [4]
4) Our final map will prepend ""hi"" to that 4 and return [""hi 4""]


Congrats, you made it all the way to the end! Hopefully, you find these array methods useful as you are writing your Ruby code. If anything is unclear, PLEASE let me know in the comments. This is my first time writing a tutorial so I welcome any and all feedback 🤗


If you would like all of these code examples without the lengthy explanations checkout this cheatsheet that @lukewduncan
 graciously put together!",Molly Struve,true
molly_struve/level-up-your-ruby-skillz-working-with-hashes-4bid,Level Up Your Ruby Skillz: Working With Hashes,"Last week I tackled Ruby arrays and shared some of the methods I find the most useful for working with them. This week I want to talk about HASHES! Before I dive head first into my favorite methods, I want to give a quick summary of what a hash is in Ruby and how it works. The definition of a Hash straight from the docs themselves:

A Hash is a dictionary-like collection(If you are a Java person, think maps) of unique keys and their values. Also called associative arrays(honestly, I have never heard this before but 🤷), they are similar to Arrays, but where an Array uses integers as its index, a Hash allows you to use any object type.

One of the keys(pun intended 😉) in that definition is that a Hash allows you to use any object type as your index. Most people when they think of a Hash think of this.

But hashes can be so much more in Ruby! For example, all of these are Hashes.

Any object type your heart desires can be a Hash key. Now that we have the semantics and the definition down, let's get to the methods!

NOTE: Just like in the array tutorial, if you see irb in the code snippets that means I am working in a Ruby console. Also, I made a code CHEAT SHEET if you want the code without all the explanations.



One of the most valuable things you can do with a hash is iterate over it. One of the easiest ways to loop over a hash is to use each. I don't know about you, but when I started out using Ruby, my hash each statements looked like this.

Here, I am executing my each method the same way I did for my arrays. The difference now is that pair is an array itself. The first element is my key and the second element is my value. NOTE: After executing the block for each of our key/value pairs, the original hash that we iterated over is returned.

The above way works, but there is an even slicker way, you can separate that pair by passing two arguments to your block. This means you can rewrite the above like this:

Now we have two separate variables, one representing the key and one representing the value.



But what if we don't want all the keys and values? What if we just want the keys or just want the values? There are methods for each of those!

Notice, that once again, regardless if we use each_key or each_value, we still get the original hash back after we are done iterating over it.



Let's say you just want an array of the keys or you just want an array of the values from a hash. To do this, you can use keys or values. Both will return an array of the keys or values for a given hash.



Another couple of pretty straight forward methods are the key and value predicates. If you want to know if a key or a value exists in a Hash then you can use key? or value?.

This is pretty straightforward, but there are a couple of nuances I want to point out. For starters, when you are looking for a key, you have to make sure you are looking for the proper datatype. For example, if you have a hash with symbol keys, searching for a string will return false.

Make sure the datatype you are searching for matches the datatype of your keys or values.



Now we know how we can check if we have a specific key or value, but what if we want to actually look up the value for a key? Well, there is always the standard way to do it and this is what I learned first.

Simple and easy. If the key is there, we return its value. If the key is not there we return nil. But what if we have some more complicated logic? For example, what if we want to return the key's value OR, if the key does not exist, we want to return some default, like 0? With what we know so far we could do this

It works, but it is a pretty decent chunk of code to get it done. Instead, we can replace that large chunk of code with one simple method, fetch. fetch has a lot of options and behaviors so lets unpack each, one at a time.

1) fetch with NO arguments will return the value if it is present. If the value is not present, fetch will raise an error. This is great if you want to raise an error when a key cannot be found.

2) fetch WITH arguments will return the value if it is present, just like before. Here is where it gets slick and can help us out with our original use case, if you pass fetch an argument and the key is not present, it will return the argument! 🔥



fetch works great when you have a single level hash and want to return a value from it using a key. But what if you have several nested hashes? For example

Normally to get the value of c you would want to do

which would traverse your nested hashes and return your value. But what if you are not sure whether all those levels are present? For example, let's say you are working with an API to get user data. Sometimes you find the user you are looking for and get this back.

Other times, you don't find the user you want and you get this back,

In this case, we can't just assume we have the user information, because if we don't have the user information, we will end up raising an error.

To avoid this, we could do

This ensures if we have the user data, we return the first name. If we don't have the data, then we return nil. Turns out, we can avoid ALL of this by using dig. dig extracts the nested value specified by a sequence of key objects. However, if any one of those nested keys do not exist, it will return nil. 🎉

dig is great when you want to traverse a hash but are not sure what its structure might be. It allows you to work with a hash without worrying about handling a bunch of errors or doing a bunch of present? checks using if/else blocks.



Now we are going to kick it up a notch. What if we have a hash where all the keys are symbols, but we want to change them all to strings? In the early days we would do this.

It works, but you guessed it, now there is a better way. That better way is transform_keys. transform_keys allows you to iterate over a hash and will return a new hash. The new hash keys will be the result from executing the block for each of the original keys.

IMPORTANT transform_keys(above) and transform_values(below) are only available in Ruby 2.5 and above. If you get the following error, then you are likely working with a version of Ruby below 2.5 NoMethodError: undefined methodtransform_keysfor {:a=>1, :b=>2, :c=>3}:Hash



transform_values works the exact same way as transform_keys, except it allows you to update the values. When it is done executing your block, it will return a new hash with the new set of values.



Now we are going to get into some familiar territory if you read my first array tutorial. Just like for arrays, you can use select for hashes! select for a hash works basically the same as an array, it returns a new hash with the key/value pairs that your block evaluated true for.



Let's say you have a hash and you just want back a specific set of keys and their values. You could do something like this

But Ruby has a simpler way and that is by using slice. slice will return a hash with only the keys you request via your arguments. What we have above can be simplified to



Back we go again to familiar array territory. reject for a hash works the same way it does for an array. reject will return a new hash consisting of all the key/value pairs for which your block returns false.



Last, but not least, we need to cover chaining. Any of the methods above that return a hash, you can chain together. For these examples I am going to use bracket notation because I think it's easier to read chaining methods from left to right, rather than up and down.

Here is an example of chaining some of the above methods together.

Let's break down what is happening here given what we learned above.
1) transform_keys changes each of the hash's keys to a string and returns { ""a"" => 1, ""b"" => 2, ""c"" => 3 , ""d"" => 4}
2) slice will select only keys ""a"" and ""b"" and their values and return { ""a"" => 1, ""b"" => 2 }
3) reject will remove any key/value pair where the value is equal to 2, that leaves us with { ""a"" => 1 }
4) Our final transform_values will change our hash's values into a string with ""hi"" and our number following it. The final result is {""a""=>""hi 1""}


You made it to the end!!! Hopefully you are feeling a little more comfortable with Ruby hashes now and have a couple more methods in your toolbox that you can use. If you have any questions or anything needs clarification please don't hesitate to drop a question in the comments!

If you want a quick reference for these methods I made a handy cheat sheet with just the code from each example.  ",Molly Struve,true
blarzhernandez/an-open-letter-to-my-readers-and-followers-thanks-p69,An Open Letter to my Readers and Followers – Thanks❤️,"Dear reader and follower,I don’t know where you are now, but I have the luck to reach you thanks to this platform, our connections are powerful.Probably for some of you, today is a normal day. However, for the rest is valentine’s day. A special day where we have the opportunity to express our affection and appreciation to our loved ones and friends. I already did it!However, in this opportunity, being honest and frank with you, knowing your important value in my growth as a human being and developer. I just wanted to give you a bunch of thanks for being part of my story. Thanks for staying and deciding to travel with me along the way. Believe it or not, every letter, every word, every paragraph, every single piece read, makes us stronger and better at the same time.I am not different than you, I am an avid reader and follower tooJust like you, I am a hungry reader. I am an avid reader. I follow people who have de ability to inspire me and become a new version of myself with their pieces or videos. You have caused that I become an obsessive reader. The more pieces I read the better I become. And you are the like too. Reading makes us more conscious and better thinkers. I am learning from others because this world will not be better in another way around. I hope you are learning something from pieces, no matter if it is a big lesson, a refresh f something, or just a small lesson. I bet to say at some point you will remember these words.If you want to go fast, go alone if you want to go far, go togetherI am so lucky that you are reading this humble letter now. Also, I am grateful you have taken to spend your priceless time to read any piece I have published before as well as for staying tuned for every next piece that will come out. That simply is awesome and it has no price!I don’t have any intention to go fast on my journey. One day at a time is enough to be alive. However, my voyage is more fun if you travel with me. Together will arrive at a better port. You and I are growing and learning at the same time.So, please accept my sincerest thanks for your support. Thanks for being part of this story. Earlier than later I bet I will be reading a similar letter from you.Feel free to reach on my blog and Medium",Roberto Hernandez,true
javinpaul/top-5-coursera-professional-certificates-to-start-advance-your-career-in-technology-185p,"","Disclosure: This post includes affiliate links; I may receive compensation if you purchase products or services from the different links provided in this article.Hello guys, If you are thinking to start or advance your career in Information Technology, Data Science and IT support but lack the necessary skills and knowledge then you don't need to disappoint. Coursera's professional certificates can give you all the knowledge, skills, and credential to start a career in Information Technology, Data Science, and IT support. If you don't know, Coursera launched Professional Certificates recently which can help you get job-ready for an in-demand career field in less than a year. You can earn a career credential, apply your knowledge to hands-on projects that showcase your skills for employers and get access to career support resources.Many of Coursera's professional certificates also provide a pathway to industry-recognized certification. Since this is a very new concept, I thought to write about it and share whatever I know. At high level, Coursera Professional certification is very similar to Coursera Specializations, which also bundles relevant courses to teach you an in-demand skill and make you job-ready by awarding a certificate once you completed all the assignments and project work.In fact, they have actually taken the Specialization into the next level by introducing Professional certificates. With these certificates, Coursera intends to bring affordable, career-aligned training programs taught by expert instructors from top companies like IBM, Google, SAS etc. and universities like University of Michigan to the everybody who wants to learn in-demand job skills to start career in tech.It's also very affordable as you can start pursuing your career dreams today with programs starting at $39 USD per month and a 7-day free trial. You can even join for free.Without wasting anymore of your time, here are some of the most popular professional certificates from Coursera to give your career a boost or learn new in-demand skills you need to break into a new career fields like information technology or data science.If you want to start our Career in Data Science & ML, then this is an excellent professional certificate for you. Data Science has been ranked as one of the hottest professions and the demand for data scientists is booming.This Professional Certificate from IBM is intended for anyone interested in developing skills and experience to pursue a career in Data Science or Machine Learning. It will teach you all the necessary technology a Data Science professional needs like Python and SQL, analyze and visualize data, build machine learning models.More than 76,173 students have already enrolled in this program, and just in case if you need, financial aid is also available.If you want to make a career in IT, then this is one of the best professional certificates you can get. It's offered by none other than Google, one of the most known IT company in the world.This program is designed to take beginner learners to job readiness in under six months and more than 90,492 have already enrolled! on this program.Coursera also offers financial aid for this program. This five-course professional certificate has an innovative curriculum designed by Google to prepare you for an entry-level role in IT support.A job in IT support means either in-person or remote help desk work in a small business or at a global company like Google.There is no doubt that Cloud computing is a very in-demand skills and probably mandatory now to start yoru career in Technology. If you want to advance your career in cloud architecture, then this is the best professional certificate you can acquire to give your career a boost. It's offered by none other than Google Cloud, which means you will be learning from the source.If you don't know the Google Cloud Professional Cloud Architect certification was ranked one of the top-paying IT certifications of 2019 by Global Knowledge, and there is a huge demand for Google Certified professionals as more and more companies are moving towards CloudThis is also a very hands-on program as you'll learn how to deploy solution elements, including infrastructure components such as networks, systems and applications services, and you'll gain real-world experience through a number of hands-on Qwiklabs projects that you can share with potential employers.If you want to launch your career with a SAS® Credential then you have come to the right place. This professional certificate offered by none other than SAS and Coursera will not only help you to master the skills required for the SAS® Base Programmer certification, but also give you the recognition you need to secure job interviews.After completing the SAS® base Programming courses, you will learn skills in manipulating and transforming data, combining SAS data sets, creating essential detail and summary reports using SAS procedures and identifying and correcting data, syntax, and programming logic errors.These skills prepare you for the SAS® Base Programmer certification exam.If you want to kick start your career with Artifical Intelligence then this is an excellent certification, to begin with. If you don't know, Artificial Intelligence or (AI) is transforming our world. Whether you're a student, developer, or a technology consultant, understanding AI and knowing how to create AI-powered applications can give you an edge in your career.This Professional Certificate, offered by IBM, one of the most reputed global IT companies, is designed to arm you with the skills to work as an AI Application Developer. More than 2,611 students have already enrolled in this program.Other Notatable Coursera Professional Certificates you can check out:That's all about some of the best professional certificates on Coursera to start or advance your career in Information Technology. I have purposefully chosen the most popular ones and also keeping the demand in mind. The list includes professional documents on IT support, Data Science, AI, Google Cloud, and SAS, which are in-demand skills. These professional certificates will not only give you experience and knowledge but also recognition. So, if you want to kickstart your career in IT support, Data Science, Artificial Intelligence, Google Cloud Platform or SAS, go for these certificates.Other Programming and Tech Articles you may likeThanks for reading this article so far. If you like these Coursera Professional certificates, then please share it with your friends and colleagues. If you have any questions or feedback, then please drop a note.",javinpaul,true
javinpaul/top-5-coursera-professional-certificates-to-start-advance-your-career-in-technology-185p,"","Disclosure: This post includes affiliate links; I may receive compensation if you purchase products or services from the different links provided in this article.Hello guys, If you are thinking to start or advance your career in Information Technology, Data Science and IT support but lack the necessary skills and knowledge then you don't need to disappoint. Coursera's professional certificates can give you all the knowledge, skills, and credential to start a career in Information Technology, Data Science, and IT support. If you don't know, Coursera launched Professional Certificates recently which can help you get job-ready for an in-demand career field in less than a year. You can earn a career credential, apply your knowledge to hands-on projects that showcase your skills for employers and get access to career support resources.Many of Coursera's professional certificates also provide a pathway to industry-recognized certification. Since this is a very new concept, I thought to write about it and share whatever I know. At high level, Coursera Professional certification is very similar to Coursera Specializations, which also bundles relevant courses to teach you an in-demand skill and make you job-ready by awarding a certificate once you completed all the assignments and project work.In fact, they have actually taken the Specialization into the next level by introducing Professional certificates. With these certificates, Coursera intends to bring affordable, career-aligned training programs taught by expert instructors from top companies like IBM, Google, SAS etc. and universities like University of Michigan to the everybody who wants to learn in-demand job skills to start career in tech.It's also very affordable as you can start pursuing your career dreams today with programs starting at $39 USD per month and a 7-day free trial. You can even join for free.Without wasting anymore of your time, here are some of the most popular professional certificates from Coursera to give your career a boost or learn new in-demand skills you need to break into a new career fields like information technology or data science.If you want to start our Career in Data Science & ML, then this is an excellent professional certificate for you. Data Science has been ranked as one of the hottest professions and the demand for data scientists is booming.This Professional Certificate from IBM is intended for anyone interested in developing skills and experience to pursue a career in Data Science or Machine Learning. It will teach you all the necessary technology a Data Science professional needs like Python and SQL, analyze and visualize data, build machine learning models.More than 76,173 students have already enrolled in this program, and just in case if you need, financial aid is also available.If you want to make a career in IT, then this is one of the best professional certificates you can get. It's offered by none other than Google, one of the most known IT company in the world.This program is designed to take beginner learners to job readiness in under six months and more than 90,492 have already enrolled! on this program.Coursera also offers financial aid for this program. This five-course professional certificate has an innovative curriculum designed by Google to prepare you for an entry-level role in IT support.A job in IT support means either in-person or remote help desk work in a small business or at a global company like Google.There is no doubt that Cloud computing is a very in-demand skills and probably mandatory now to start yoru career in Technology. If you want to advance your career in cloud architecture, then this is the best professional certificate you can acquire to give your career a boost. It's offered by none other than Google Cloud, which means you will be learning from the source.If you don't know the Google Cloud Professional Cloud Architect certification was ranked one of the top-paying IT certifications of 2019 by Global Knowledge, and there is a huge demand for Google Certified professionals as more and more companies are moving towards CloudThis is also a very hands-on program as you'll learn how to deploy solution elements, including infrastructure components such as networks, systems and applications services, and you'll gain real-world experience through a number of hands-on Qwiklabs projects that you can share with potential employers.If you want to launch your career with a SAS® Credential then you have come to the right place. This professional certificate offered by none other than SAS and Coursera will not only help you to master the skills required for the SAS® Base Programmer certification, but also give you the recognition you need to secure job interviews.After completing the SAS® base Programming courses, you will learn skills in manipulating and transforming data, combining SAS data sets, creating essential detail and summary reports using SAS procedures and identifying and correcting data, syntax, and programming logic errors.These skills prepare you for the SAS® Base Programmer certification exam.If you want to kick start your career with Artifical Intelligence then this is an excellent certification, to begin with. If you don't know, Artificial Intelligence or (AI) is transforming our world. Whether you're a student, developer, or a technology consultant, understanding AI and knowing how to create AI-powered applications can give you an edge in your career.This Professional Certificate, offered by IBM, one of the most reputed global IT companies, is designed to arm you with the skills to work as an AI Application Developer. More than 2,611 students have already enrolled in this program.Other Notatable Coursera Professional Certificates you can check out:That's all about some of the best professional certificates on Coursera to start or advance your career in Information Technology. I have purposefully chosen the most popular ones and also keeping the demand in mind. The list includes professional documents on IT support, Data Science, AI, Google Cloud, and SAS, which are in-demand skills. These professional certificates will not only give you experience and knowledge but also recognition. So, if you want to kickstart your career in IT support, Data Science, Artificial Intelligence, Google Cloud Platform or SAS, go for these certificates.Other Programming and Tech Articles you may likeThanks for reading this article so far. If you like these Coursera Professional certificates, then please share it with your friends and colleagues. If you have any questions or feedback, then please drop a note.",javinpaul,false
daolf/the-25-most-recommended-programming-books-of-all-time-5fel,The 25 most recommended programming books of all-time.,"This article is a follow up of the one I did about the the most recommended startup books of all-time.If you've read this one recently. I guess you can jump straight to the results.There are countless lists on the internet claiming to be the list of must-read programming books and it seemed that all those lists always recommended that same books minus two or three odd choices.Finding good resources for learning programming is always tricky. Every-one has its own opinion about what book is the best to learn, and as we say in french, ""Color and tastes should not be argued about"".However I thought it would be interesting to trust the wisdom of the crown and to find the books that appeared the most in those ""Best Programming Book"" lists.If you want to jump right on the results go take a look below at the full results. If you want to learn about the methodology, bear with me.Disclaimer: I spent countless hours on this article so I've decided to put Amazon affiliation links to see if those kinds of detailed articles could be a viable source of revenue, ... or not 🤷‍♂️.I've simply asked Google for a few queries like ""Best Programming Books"" and its variations. I have then scrapped all those pages (using ScrapingBee, a web scraping API I'm working on).I've deduplicated the links and ended up with nearly 150 links. Using the title of the pages I was also able to quickly discards:I ended up with almost 200 HTML files. I went on opening all the files on my browser, open my chrome inspector, found and wrote the CSS selector matching book titles in the article. This took me around 1hours, almost 30 seconds per page. This also allowed me to discard even more nonrelevant pages, and I discarded a lot. In the end, I compiled around 70 lists into this one.At this moment I had this big JSON file referencing the HTML page previously scrapped, and a CSS selector.Using Python with Beautiful soup, I've extracted every text inside DOM elements that matched the CSS selector. I ended up with a huge list of books, not usable without some post-processing.To find the most quoted startup books I needed to normalize my results. I had to play with  all the different variation like ""{title} by {author}"" or ""{title} - {author}"".Or ""{title}:{subtitle}"" and ""{title}"", or even all the one containing edition number. I ended up doing it using this simple custom Python function:
and quite a bit of manual cleaning.My list now looked like this:From there it was easy to compute the most recommended books. You can find all the data used to process this list on this repo. Now let's take a look at the list:""Getting software released to users is often a painful, risky, and time-consuming process. This groundbreaking new book sets out the principles and technical practices that enable rapid, incremental delivery of high quality, valuable new functionality to users. Through automation of the build, deployment, and testing process, and improved collaboration between developers, testers, and operations, delivery teams can get changes released in a matter of hours, sometimes even minutes–no matter what the size of a project or the complexity of its code base.Jez Humble and David Farley begin by presenting the foundations of a rapid, reliable, low-risk delivery process. Next, they introduce the “deployment pipeline,” an automated process for managing all changes, from check-in to release. Finally, they discuss the “ecosystem” needed to
support continuous delivery, from infrastructure, data and configuration management to governance."" Amazon.com
""The algorithms in this book represent a body of knowledge developed over the last 50 years that has become indispensable, not just for professional programmers and computer science students but for any student with interests in science, mathematics, and engineering, not to mention students who use computation in the liberal arts.""Amazon.com
""I am a self-taught programmer. After a year of self-study, I learned to program well enough to land a job as a software engineer II at eBay. Once I got there, I realized I was severely under-prepared. I was overwhelmed by the amount of things I needed to know but hadn't learned yet. My journey learning to program, and my experience at my first job as a software engineer were the inspiration for this book. This book is not just about learning to program; although you will learn to code. If you want to program professionally, it is not enough to learn to code; that is why, in addition to helping you learn to program, I also cover the rest of the things you need to know to program professionally that classes and books don't teach you. ""The Self-taught Programmer"" is a roadmap, a guide to take you from writing your first Python program, to passing your first technical interview. The path is there. Will you take it?""Amazon.com
""Corporate and commercial software-development teams all want solutions for one important problem—how to get their high-pressure development schedules under control. In RAPID DEVELOPMENT, author Steve McConnell addresses that concern head-on with overall strategies, specific best practices, and valuable tips that help shrink and control development schedules and keep projects moving. Inside, you’ll find:
""This is a who's who in the programming world - a fascinating look at how some of the best in the world do their work. Patterned after the best selling Founders at Work, the book represents two years of interviews with some of the top programmers of our times.""Amazon.com
""Leading software designers have recognized domain modeling and design as critical topics for at least twenty years, yet surprisingly little has been written about what needs to be done or how to do it. Although it has never been clearly formulated, a philosophy has developed as an undercurrent in the object community, which I call ""domain-driven design"".I have spent the past decade focused on developing complex systems in several business and technical domains. I've tried best practices in design and development process as they have emerged from the leaders in the object-oriented development community. Some of my projects were very successful; a few failed. A feature common to the successes was a rich domain model that evolved through iterations of design and became part of the fabric of the project.This book provides a framework for making design decisions and a technical vocabulary for discussing domain design. It is a synthesis of widely accepted best practices along with my own insights and experiences. Projects facing complex domains can use this framework to approach domain-driven design systematically.""Amazon.com
""Countless readers have spoken about the profound personal influence of Knuth’s work. Scientists have marveled at the beauty and elegance of his analysis, while ordinary programmers have successfully applied his “cookbook” solutions to their day-to-day problems. All have admired Knuth for the breadth, clarity, accuracy, and good humor found in his books.""Amazon.com
""Structure and Interpretation of Computer Programs has had a dramatic impact on computer science curricula over the past decade. This long-awaited revision contains changes throughout the text. There are new implementations of most of the major programming systems in the book, including the interpreters and compilers, and the authors have incorporated many small changes that reflect their experience teaching the course at MIT since the first edition was published. A new theme has been introduced that emphasizes the central role played by different approaches to dealing with time in computational models: objects with state, concurrent programming, functional programming and lazy evaluation, and nondeterministic programming. There are new example sections on higher-order procedures in graphics and on applications of stream processing in numerical programming, and many new exercises. In addition, all the programs have been reworked to run in any Scheme implementation that adheres to the IEEE standard.""Amazon.com
""The practice of enterprise application development has benefited from the emergence of many new enabling technologies. Multi-tiered object-oriented platforms, such as Java and .NET, have become commonplace. These new tools and technologies are capable of building powerful applications, but they are not easily implemented. Common failures in enterprise applications often occur because their developers do not understand the architectural lessons that experienced object developers have learned.""Amazon.com
""Computer programming has many faces. Fred Brooks paints the big picture in The Mythical Man Month; his essays underscore the crucial role of management in large software projects. At a finer grain, Steve McConnell teaches good programming style in Code Complete. The topics in those books are the key to good software and the hallmark of the professional programmer. Unfortunately, though, the workmanlike application of those sound engineering principles isn't always thrilling -- until the software is completed on time and works without surprise.The columns in this book are about a more glamorous aspect of the profession: programming pearls whose origins lie beyond solid engineering, in the realm of insight and creativity. Just as natural pearls grow from grains of sand that have irritated oysters, these programming pearls have grown from real problems that have irritated real programmers. The programs are fun, and they teach important programming techniques and fundamental design principles.""Amazon.com
""Drawing on their software development and management experience, and highlighting the insights and wisdom of other successful managers, Mantle and Lichty provide the rules, tools, and insights you need to manage and understand people and teams in order to deliver software successfully and avoid projects that have run catastrophically over schedule and budget.  The unique insight of this longtime bestseller is that the major issues of software development are human, not technical. They're not easy issues; but solve them, and you'll maximize your chances of success. With a blend of software engineering facts and thought-provoking opinions, Fred Brooks offers insight for anyone managing complex projects.""Amazon.com
""Some books on algorithms are rigorous but incomplete; others cover masses of material but lack rigor. Introduction to Algorithms uniquely combines rigor and comprehensiveness. The book covers a broad range of algorithms in depth, yet makes their design and analysis accessible to all levels of readers. Each chapter is relatively self-contained and can be used as a unit of study. The algorithms are described in English and in a pseudocode designed to be readable by anyone who has done a little programming. The explanations have been kept elementary without sacrificing depth of coverage or mathematical rigor.The first edition became a widely used text in universities worldwide as well as the standard reference for professionals. The second edition featured new chapters on the role of algorithms, probabilistic analysis and randomized algorithms, and linear programming. The third edition has been revised and updated throughout. It includes two completely new chapters, on van Emde Boas trees and multithreaded algorithms, substantial additions to the chapter on recurrence (now called “Divide-and-Conquer”), and an appendix on matrices. It features improved treatment of dynamic programming and greedy algorithms and a new notion of edge-based flow in the material on flow networks. Many exercises and problems have been added for this edition. The international paperback edition is no longer available; the hardcover is available worldwide.""Amazon.com
""What do flashlights, the British invasion, black cats, and seesaws have to do with computers? In CODE, they show us the ingenious ways we manipulate language and invent new means of communicating with each other. And through CODE, we see how this ingenuity and our very human compulsion to communicate have driven the technological innovations of the past two centuries.Using everyday objects and familiar language systems such as Braille and Morse code, author Charles Petzold weaves an illuminating narrative for anyone who’s ever wondered about the secret inner life of computers and other smart machines.It’s a cleverly illustrated and eminently comprehensible story—and along the way, you’ll discover you’ve gained a real context for understanding today’s world of PCs, digital media, and the Internet. No matter what your level of technical savvy, CODE will charm you—and perhaps even awaken the technophile within.""Amazon.com
""Since Don’t Make Me Think was first published in 2000, hundreds of thousands of Web designers and developers have relied on usability guru Steve Krug’s guide to help them understand the principles of intuitive navigation and information design. Witty, commonsensical, and eminently practical, it’s one of the best-loved and most recommended books on the subject.Now Steve returns with fresh perspective to reexamine the principles that made Don’t Make Me Think a classic–with updated examples and a new chapter on mobile usability. And it’s still short, profusely illustrated…and best of all–fun to read.If you’ve read it before, you’ll rediscover what made Don’t Make Me Think so essential to Web designers and developers around the world. If you’ve never read it, you’ll see why so many people have said it should be required reading for anyone working on Web sites.""Amazon.com
""For most software developers, coding is the fun part. The hard bits are dealing with clients, peers, and managers, staying productive, achieving financial security, keeping yourself in shape, and finding true love. This book is here to help.Soft Skills: The software developer's life manual is a guide to a well-rounded, satisfying life as a technology professional. In it, developer and life coach John Sonmez offers advice to developers on important ""soft"" subjects like career and productivity, personal finance and investing, and even fitness and relationships. Arranged as a collection of 71 short chapters, this fun-to-read book invites you to dip in wherever you like. A Taking Action section at the end of each chapter shows you how to get quick results. Soft Skills will help make you a better programmer, a more valuable employee, and a happier, healthier person.""Amazon.com
""I am not a recruiter. I am a software engineer. And as such, I know what it's like to be asked to whip up brilliant algorithms on the spot and then write flawless code on a whiteboard. I've been through this as a candidate and as an interviewer.Cracking the Coding Interview, 6th Edition is here to help you through this process, teaching you what you need to know and enabling you to perform at your very best. I've coached and interviewed hundreds of software engineers. The result is this book.Learn how to uncover the hints and hidden details in a question, discover how to break down a problem into manageable chunks, develop techniques to unstick yourself when stuck, learn (or re-learn) core computer science concepts, and practice on 189 interview questions and solutions.These interview questions are real; they are not pulled out of computer science textbooks. They reflect what's truly being asked at the top companies, so that you can be as prepared as possible. WHAT'S INSIDE?
""Capturing a wealth of experience about the design of object-oriented software, four top-notch designers present a catalog of simple and succinct solutions to commonly occurring design problems. Previously undocumented, these 23 patterns allow designers to create more flexible, elegant, and ultimately reusable designs without having to rediscover the design solutions themselves.The authors begin by describing what patterns are and how they can help you design object-oriented software. They then go on to systematically name, explain, evaluate, and catalog recurring designs in object-oriented systems. With Design Patterns as your guide, you will learn how these important patterns fit into the software development process, and how you can leverage them to solve your own design problems most efficiently.Each pattern describes the circumstances in which it is applicable, when it can be applied in view of other design constraints, and the consequences and trade-offs of using the pattern within a larger design. All patterns are compiled from real systems and are based on real-world examples. Each pattern also includes code that demonstrates how it may be implemented in object-oriented programming languages like C++ or Smalltalk.""Amazon.com
""In this book, Michael Feathers offers start-to-finish strategies for working more effectively with large, untested legacy code bases. This book draws on material Michael created for his own renowned Object Mentor seminars: techniques Michael has used in mentoring to help hundreds of developers, technical managers, and testers bring their legacy systems under control.
This book also includes a catalog of twenty-four dependency-breaking techniques that help you work with program elements in isolation and make safer changes.""Amazon.com
""Programmers who endure and succeed amidst swirling uncertainty and nonstop pressure share a common attribute: They care deeply about the practice of creating software. They treat it as a craft. They are professionals.In The Clean Coder: A Code of Conduct for Professional Programmers, legendary software expert Robert C. Martin introduces the disciplines, techniques, tools, and practices of true software craftsmanship. This book is packed with practical advice–about everything from estimating and coding to refactoring and testing. It covers much more than technique: It is about attitude. Martin shows how to approach software development with honor, self-respect, and pride; work well and work clean; communicate and estimate faithfully; face difficult decisions with clarity and honesty; and understand that deep knowledge comes with a responsibility to act.Great software is something to marvel at: powerful, elegant, functional, a pleasure to work with as both a developer and as a user. Great software isn’t written by machines. It is written by professionals with an unshakable commitment to craftsmanship. The Clean Coder will help you become one of them–and earn the pride and fulfillment that they alone possess.""Amazon.com
""Few books on software project management have been as influential and timeless as The Mythical Man-Month. With a blend of software engineering facts and thought-provoking opinions, Fred Brooks offers insight for anyone managing complex projects. These essays draw from his experience as project manager for the IBM System/360 computer family and then for OS/360, its massive software system. Now, 20 years after the initial publication of his book, Brooks has revisited his original ideas and added new thoughts and advice, both for readers already familiar with his work and for readers discovering it for the first time.""Amazon.com
""What’s so special about design patterns?At any given moment, someone struggles with the same software design problems you have. And, chances are, someone else has already solved your problem. This edition of Head First Design Patterns—now updated for Java 8—shows you the tried-and-true, road-tested patterns used by developers to create functional, elegant, reusable, and flexible software. By the time you finish this book, you’ll be able to take advantage of the best design practices and experiences of those who have fought the beast of software design and triumphed.What’s so special about this book?We think your time is too valuable to spend struggling with new concepts. Using the latest research in cognitive science and learning theory to craft a multi-sensory learning experience, Head First Design Patterns uses a visually rich format designed for the way your brain works, not a text-heavy approach that puts you to sleep.""Amazon.com
""As the application of object technology--particularly the Java programming language--has become commonplace, a new problem has emerged to confront the software development community. Significant numbers of poorly designed programs have been created by less-experienced developers, resulting in applications that are inefficient and hard to maintain and extend. Increasingly, software system professionals are discovering just how difficult it is to work with these inherited, non-optimal applications. For several years, expert-level object programmers have employed a growing collection of techniques to improve the structural integrity and performance of such existing software programs. Referred to as refactoring, these practices have remained in the domain of experts because no attempt has been made to transcribe the lore into a form that all developers could use. . .until now. In Refactoring: Improving the Design of Existing Software, renowned object technology mentor Martin Fowler breaks new ground, demystifying these master practices and demonstrating how software practitioners can realize the significant benefits of this new process. With proper training a skilled system designer"" Amazon.com
""Widely considered one of the best practical guides to programming, Steve McConnell’s original CODE COMPLETE has been helping developers write better software for more than a decade. Now this classic book has been fully updated and revised with leading-edge practices—and hundreds of new code samples—illustrating the art and science of software construction. Capturing the body of knowledge available from research, academia, and everyday commercial practice, McConnell synthesizes the most effective techniques and must-know principles into clear, pragmatic guidance. No matter what your experience level, development environment, or project size, this book will inform and stimulate your thinking—and help you build the highest quality code.""Amazon.com
""Clean Code is divided into three parts. The first describes the principles, patterns, and practices of writing clean code. The second part consists of several case studies of increasing complexity. Each case study is an exercise in cleaning up code—of transforming a code base that has some problems into one that is sound and efficient. The third part is the payoff: a single chapter containing a list of heuristics and “smells” gathered while creating the case studies. The result is a knowledge base that describes the way we think when we write, read, and clean code.""Amazon.com
""
The Pragmatic Programmer is one of those rare tech books you’ll read, re-read, and read again over the years. Whether you’re new to the field or an experienced practitioner, you’ll come away with fresh insights each and every time.Dave Thomas and Andy Hunt wrote the first edition of this influential book in 1999 to help their clients create better software and rediscover the joy of coding. These lessons have helped a generation of programmers examine the very essence of software development, independent of any particular language, framework, or methodology, and the Pragmatic philosophy has spawned hundreds of books, screencasts, and audio books, as well as thousands of careers and success stories.Now, twenty years later, this new edition re-examines what it means to be a modern programmer. Topics range from personal responsibility and career development to architectural techniques for keeping your code flexible and easy to adapt and reuse.""Amazon.comAlthough the order might suprise some, by definition, most of you must have heard of these books already.A few additional things I learned making this list: I hope you enjoyed this article. I must admit, this one took a while to write. If you liked this article and feel like Twitter would like it please do not hesitate to love and retweet, it really does help :). (do NOT create an account just for this though)Do not hesitate to follow me if you don't want to miss my next posts. I write about tech, my boostraping journey and I occasionnaly write more data analysis article like this one.Note: while making this article, this one appeared in the Google results. I ended up doing mine anyway because I would use a different automated aggregation technique that allowed be to compiled twice as much lists as he did. However, checking both list could be interesting :).",Pierre,true
